<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doppler Effect (Dual Frame Control)</title>
    <style>
        /* --- LAYOUT & THEME --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #ffe4c8;
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .diagram-container {
            width: 100%;
            height: 100%;
            background: #ffe4c8;
            display: flex;
            flex-direction: column;
            padding: 15px;
            box-sizing: border-box;
        }

        #waveCanvas {
            width: 100%;
            flex-grow: 1;
            height: 0;
            background-color: #2a2a2a;
            border-radius: 8px;
            border: 1px solid #333;
            margin-bottom: 10px;
            cursor: crosshair;
        }

        /* --- CONTROLS UI --- */
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 0.85em;
            color: #555;
            font-weight: 600;
            flex-shrink: 0;
        }

        .dot {
            width: 10px; height: 10px; display: inline-block;
            border-radius: 50%; margin-right: 6px; vertical-align: middle;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            flex-shrink: 0;
            padding-bottom: 5px;
        }

        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
            width: 100%;
            justify-content: center;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-grow: 1;
            max-width: 500px;
            font-weight: 500;
            color: #444;
        }

        input[type=range] {
            flex-grow: 1;
            height: 6px;
            background: #ddd;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #ff4444;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }

        input[type=range]::-webkit-slider-thumb:hover { background: #cc0000; }

        button {
            padding: 8px 15px;
            background-color: #0b1021;
            color: #fff;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            min-width: 100px;
            transition: 0.2s;
            font-size: 0.9em;
            letter-spacing: 0.5px;
        }

        /* Specific style for frame buttons to look togglable */
        .frame-btn {
            background-color: #eee;
            color: #333;
            border: 1px solid #ccc;
        }

        .frame-btn:hover {
            background-color: #ddd;
        }

        button.active {
            background-color: #ff0055;
            border-color: #ff0055;
            color: white;
            box-shadow: 0 2px 10px rgba(255, 0, 85, 0.3);
        }

        /* Override frame-btn specific hover if active */
        .frame-btn.active:hover {
            background-color: #e6004c;
            color: white;
        }

        button:hover { opacity: 0.9; }
    </style>
</head>
<body>

<div class="diagram-container">
    <canvas id="waveCanvas"></canvas>

    <div class="legend">
        <span><span class="dot" style="background:#ff4444;"></span>Source</span>
        <span><span class="dot" style="border: 2px solid rgba(255, 68, 68, 0.8); box-sizing: border-box;"></span>Wavefront</span>
        <span><span class="dot" style="background:rgba(255, 255, 255, 0.5);"></span>Emission Point</span>
    </div>

    <div class="controls">
        <div class="control-row">
            <button id="togglePlay">Play</button>
            <div class="slider-group">
                <span>Time (t):</span>
                <input type="range" id="timeSlider" min="0" max="1500" value="0" step="1">
            </div>
        </div>

        <div class="control-row" style="background: #f0d8bd; padding: 10px; border-radius: 8px; width: auto;">
            <button id="btnFixed" class="frame-btn active">Rest Frame</button>
            <button id="btnMoving" class="frame-btn">Moving Frame</button>

            <div style="font-size: 0.85em; color: #665; margin-left: 15px; display: flex; flex-direction: column; justify-content: center;">
                <span id="velocityLabel">Velocity = 0</span>
            </div>
        </div>
    </div>
</div>

<script>
    // --- Elements ---
    const canvas = document.getElementById('waveCanvas');
    const ctx = canvas.getContext('2d');
    const timeSlider = document.getElementById('timeSlider');
    const playBtn = document.getElementById('togglePlay');

    // New Button & Label References
    const btnFixed = document.getElementById('btnFixed');
    const btnMoving = document.getElementById('btnMoving');
    const velocityLabel = document.getElementById('velocityLabel');

    // --- State & Configuration ---
    let width, height;

    const state = {
        time: 0,
        isPlaying: false,
        isMoving: false, // Default to Fixed
        maxTime: 1500
    };

    const config = {
        waveSpeed: 0.4,
        sourceSpeedRatio: 0.9,
        baseEmissionRate: 50 // Base ticks between emissions (Proper Time)
    };

    // --- Logic ---

    function resize() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        width = rect.width;
        height = rect.height;
        draw();
    }
    window.addEventListener('resize', resize);

    function getSourcePosition(t) {
        const startX = width * 0.2;
        const startY = height / 2;

        if (!state.isMoving) {
            return { x: startX, y: startY };
        }

        const speed = config.waveSpeed * config.sourceSpeedRatio;
        const currentX = startX + (speed * t);
        return { x: currentX, y: startY };
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);

        // --- TIME DILATION LOGIC ---
        // 1. Determine the interval between emissions in the "Lab Frame"
        let emissionInterval = config.baseEmissionRate;

        if (state.isMoving) {
            // Calculate Gamma: Î³ = 1 / sqrt(1 - v^2/c^2)
            const beta = config.sourceSpeedRatio;
            const gamma = 1 / Math.sqrt(1 - (beta * beta));

            // Lab Interval = Proper Interval * Gamma
            emissionInterval = config.baseEmissionRate * gamma;
        }

        // 2. Loop through history using the calculated interval
        for (let t_emit = 0; t_emit <= state.time; t_emit += emissionInterval) {

            const origin = getSourcePosition(t_emit);
            const age = state.time - t_emit;
            const radius = age * config.waveSpeed;

            const maxRadius = width * 1.2;
            const alpha = Math.max(0, 1 - (radius / maxRadius));

            if (alpha <= 0) continue;

            // Draw Wave
            ctx.beginPath();
            ctx.arc(origin.x, origin.y, radius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 68, 68, ${alpha})`;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw Emission Point
            if (age > 0) {
                ctx.beginPath();
                ctx.arc(origin.x, origin.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(200, 200, 200, ${alpha * 0.6})`;
                ctx.fill();
            }
        }

        // 3. Draw Current Source
        const source = getSourcePosition(state.time);

        if (state.isMoving) {
            const startX = width * 0.2;
            ctx.beginPath();
            ctx.moveTo(startX, height/2);
            ctx.lineTo(source.x, source.y);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        ctx.beginPath();
        ctx.arc(source.x, source.y, 8, 0, Math.PI * 2);
        ctx.fillStyle = '#ff4444';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ff0000';
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    // --- Interaction ---

    timeSlider.addEventListener('input', (e) => {
        state.time = parseInt(e.target.value);
        if (state.isPlaying) togglePlay();
        draw();
    });

    // Helper to switch modes
    function setFrameMode(targetIsMoving) {
        // Calculate Gamma (approx 2.29 for beta=0.9)
        const beta = config.sourceSpeedRatio;
        const gamma = 1 / Math.sqrt(1 - (beta * beta));

        // --- UPDATED LOGIC HERE ---
        // Do not reset time. Convert it instead.

        // CASE 1: Switching from REST (Fixed) to MOVING
        // We are currently in "Lab Time". We want to see "Proper Time".
        // Proper Time = Lab Time / Gamma
        if (!state.isMoving && targetIsMoving) {
            state.time = state.time / gamma;
        }

        // CASE 2: Switching from MOVING to REST (Fixed)
        // We are currently in "Proper Time". We want to see "Lab Time".
        // Lab Time = Proper Time * Gamma
        else if (state.isMoving && !targetIsMoving) {
            state.time = state.time * gamma;
        }

        // Apply new state
        state.isMoving = targetIsMoving;

        // Update slider value to match the calculated time
        timeSlider.value = state.time;

        // Button Styling
        if (targetIsMoving) {
            btnMoving.classList.add('active');
            btnFixed.classList.remove('active');
            velocityLabel.textContent = "Velocity = 0.9c";
        } else {
            btnFixed.classList.add('active');
            btnMoving.classList.remove('active');
            velocityLabel.textContent = "Velocity = 0";
        }
        draw();
    }

    btnFixed.addEventListener('click', () => setFrameMode(false));
    btnMoving.addEventListener('click', () => setFrameMode(true));

    playBtn.addEventListener('click', togglePlay);

    function togglePlay() {
        state.isPlaying = !state.isPlaying;
        playBtn.textContent = state.isPlaying ? "Pause" : "Play";

        if (state.isPlaying) {
            playBtn.classList.add('active');
            loop();
        } else {
            playBtn.classList.remove('active');
        }
    }

    function loop() {
        if (!state.isPlaying) return;
        state.time += 2;

        const sourcePos = getSourcePosition(state.time);

        // Loop condition (reset if off screen or max time reached)
        if (sourcePos.x > width + 100 || state.time >= state.maxTime) {
            state.time = 0;
        }

        timeSlider.value = state.time;
        draw();
        requestAnimationFrame(loop);
    }

    setTimeout(resize, 50);
</script>

</body>
</html>